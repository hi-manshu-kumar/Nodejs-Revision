{
    email: 'hiam@gmail.com',
    password: 'adkd',
    tokens : [{
        access: 'auth',
        tokens: 'dskjfdl'
    }]
}

we have to first create a schema for the user

var User = mongoose.model('User', {
    email:{
        type: String,
        required: true,
        trim: true,
        minlength: 1,
        unique: true,
        validate: validator.isEmail,
        message: '{VALUE} is not valid email'
    },
    password: {
        type: String,
        require: true,
        minlength: 6
    },
    tokens: [{
        access: {
            type: String,
            required: true
        },
        token: {
            type: String,
            required: true
        }
    }]
});

now we need to validate a email address we have another library called the `validator`
        unique: true,
        validate: validator.isEmail,
        message: '{VALUE} is not valid email'
--------------
now add the POST users to handle the addtition of the users

app.post("/users", (req, res) => {
    var body = _.pick(req.body, ['email','password']); 
    var user = new User(body);

    user.save().then((user) => {
        res.send(user);
    }).catch((e) => res.status(404).send(e))
});
------------------------------------------------------------
hasing and web tokens

we do hashing to convert the data in a unique string that is unreadable
but we also want to add some secret key to this string so that if anyone tries to manually add the token in the req
we will check wether the token have that secret keyword or not
this addition of secret keyword is called salting

-------->
const {SHA256} = require('crypto-js');
const jwt = require('jsonwebtoken');

var data ={
    id: 10
};

var token = jwt.sign(data, '123abc');
console.log(token);

var decoded = jwt.verify(token , '123abc');
console.log("decoded ",decoded );
------------->
generating auth tokens and setting headers
headers contain the tokens and this token gives the details of the person that is logged in by "x-auth"
 till now the user just signs up but no token were generated   
 model method and instance method on User and user resp.  for eg user.generateAuthToken User.findByToken 

`in serverjs`
// POST /users
app.post('/users', (req, res) => {
    var body = _.pick(req.body, ['email', 'password']);
    var user = new User(body);
  
    user.save().then(() => {
        return user.generateAuthToken();
    }).then((token) => {
        res.header('x-auth', token).send(user);
    }).catch((e) => {
        res.status(400).send(e);
    })
});

`in user.js`
UserSchema.methods.toJSON = function (){            // for limiting the data sending a s a response to the client
    var user = this;                                // we just keep the id and the email as the response and removing all the tokens data from response
    var userObject = user.toObject();

    return _.pick(userObject, ['_id', 'email'])
}

UserSchema.methods.generateAuthToken = function () {
    var user = this;
    var access = 'auth';
    var token = jwt.sign({_id: user._id.toHexString(), access}, 'abc123').toString();

    user.tokens = user.tokens.concat([{access, token}]);

    return user.save().then(() => {
        return token;
    });
};

var User = mongoose.model('User', UserSchema);
-------------------------------------------------------------------------------------
private route and auth middleware

convert express route in private route 
require x auth validate  that token,find user associarted with that token

res.header lets us set header
req.header lets us get header

`in server.js`
const {authenticate} = require('./middleware/authenticate');

app.get('/users/me', authenticate, (req,res) => {
    res.send(req.user);                                             //we called the authenticate it gives us the user and email by checking the header
});                                                                 //and finding it in using findByToken in user. js             

`in authenticate`
var {User} = require('../models/user');

var authenticate = (req, res, next) => {
    var token = req.header('x-auth');
    console.log(token);
    User.findByToken(token).then((user) => {                //model method
        if(!user) {
            return Promise.reject();
        }

        req.user = user;
        req.token = token;
        next();
    }).catch((e) => {
        res.status(401).send();
    });
}

module.exports = {authenticate};

`in user.js`
UserSchema.statics.findByToken = function(token) {      // it is an object kind of method, everything you add on turns into model method and not supposed to instance method
    var User = this;
    var decoded;

    try{
        decoded = jwt.verify(token, 'abc123');
    } catch(e){
        // return new Promise((resolve, reject) => {
        //     reject();
        // });
        return Promise.reject();
    }
    return User.findOne({
        _id: decoded._id,
        'tokens.token': token,
        'tokens.access': 'auth'
    });
} 
----------------------------------------------------------------------------------------
hashing password
bcrypt for salting and hashing 
npm i bcryptjs@2.3.0 --save

`go to playground/hashing.js`

`in user.js`
const bcrypt =require('bcryptjs');

UserSchema.pre('save', function(next) {             // we have to check if the password is changed or not if it is then only we use hashing
    var user =this;                                 // we add this middleware in b/w the userschmea save so that we can hash the password

    if(user.isModified('password')) {
        bcrypt.genSalt(10, (err, salt) => {
            bcrypt.hash(user.password, salt, (err, hash)=> {
                user.password = hash;
                next();
            });
        });
    } else {
        next();
    }
});
----------------------------------------------------------------------------------------------
seeding test dtaatbase with users
`in seed.js`
`in server.test.js`
------------------------------------------------------------------------------
POST users/login

`in server.js`
//POST /users/login {email, password}
app.post('/users/login', (req, res) => {
    var body = _.pick(req.body, ['email', 'password']);

    User.findByCredentials(body.email, body.password).then((user) => {
        return user.generateAuthToken().then((token) => {
            res.header('x-auth', token).send(user);
        });
    }).catch( (e) => {
        res.status(400).send();
    });
})

`in user.js`
UserSchema.statics.findByCredentials = function (email, password) {
    var User = this;

    return User.findOne({email}).then((user)=> {
        if(!user) {
            return Promise.reject();
        }

        return new Promise((resolve, reject) => {
            bcrypt.compare(password, user.password, (err, res) => {
                if(res){
                    resolve(user);
                } else{
                    reject();
                }
            });
        });
    });
};
------------------------------------------------------------------------------
deleting tokens

`in server.js`
app.delete('/users/me/token', authenticate, (req, res) => {
    req.user.removeToken(req.token).then(() => {
        res.status(200).send();
    }, () => {
        res.status(400).send();
    });  
});

`in user.js`
UserSchema.methods.removeToken = function (token) {     //instance method
    var user = this;
    return user.update({
        $pull: {
            tokens: {
                token: token
            }
        }
    });
};