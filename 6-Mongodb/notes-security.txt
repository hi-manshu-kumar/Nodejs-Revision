{
    email: 'hiam@gmail.com',
    password: 'adkd',
    tokens : [{
        access: 'auth',
        tokens: 'dskjfdl'
    }]
}

we have to first create a schema for the user

var User = mongoose.model('User', {
    email:{
        type: String,
        required: true,
        trim: true,
        minlength: 1,
        unique: true,
        validate: validator.isEmail,
        message: '{VALUE} is not valid email'
    },
    password: {
        type: String,
        require: true,
        minlength: 6
    },
    tokens: [{
        access: {
            type: String,
            required: true
        },
        token: {
            type: String,
            required: true
        }
    }]
});

now we need to validate a email address we have another library called the `validator`
        unique: true,
        validate: validator.isEmail,
        message: '{VALUE} is not valid email'
--------------
now add the POST users to handle the addtition of the users

app.post("/users", (req, res) => {
    var body = _.pick(req.body, ['email','password']); 
    var user = new User(body);

    user.save().then((user) => {
        res.send(user);
    }).catch((e) => res.status(404).send(e))
});
------------------------------------------------------------
hasing and web tokens

we do hashing to convert the data in a unique string that is unreadable
but we also want to add some secret key to this string so that if anyone tries to manually add the token in the req
we will check wether the token have that secret keyword or not
this addition of secret keyword is called salting

-------->
const {SHA256} = require('crypto-js');
const jwt = require('jsonwebtoken');

var data ={
    id: 10
};

var token = jwt.sign(data, '123abc');
console.log(token);

var decoded = jwt.verify(token , '123abc');
console.log("decoded ",decoded );
------------->
generating auth tokens and setting headers
headers contain the tokens and this token gives the details of the person that is logged in by "x-auth"
 till now the user just signs up but no token were generated   
 model method and instance method on User and user resp.  for eg user.generateAuthToken User.findByToken 

`in serverjs`
// POST /users
app.post('/users', (req, res) => {
    var body = _.pick(req.body, ['email', 'password']);
    var user = new User(body);
  
    user.save().then(() => {
        return user.generateAuthToken();
    }).then((token) => {
        res.header('x-auth', token).send(user);
    }).catch((e) => {
        res.status(400).send(e);
    })
});

`in user.js`
UserSchema.methods.toJSON = function (){            // for limiting the data sending a s a response to the client
    var user = this;                                // we just keep the id and the email as the response and removing all the tokens data from response
    var userObject = user.toObject();

    return _.pick(userObject, ['_id', 'email'])
}

UserSchema.methods.generateAuthToken = function () {
    var user = this;
    var access = 'auth';
    var token = jwt.sign({_id: user._id.toHexString(), access}, 'abc123').toString();

    user.tokens = user.tokens.concat([{access, token}]);

    return user.save().then(() => {
        return token;
    });
};

var User = mongoose.model('User', UserSchema);